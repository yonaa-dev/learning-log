# Week 01 — Runtime & Async

> 기간: 2026.01.08 ~ 2026.01.14

## 이번 주의 핵심 질문
자바스크립트는 단일 스레드인데, 어떻게 비동기 처리가 가능한가?

---

## 이번 주에 집중한 내용

비동기 동작을 “결과”가 아니라  
**실행 구조와 책임 분리 관점**에서 이해하는 데 집중했다.

- 자바스크립트 런타임 구조
- JS 엔진과 브라우저(Web API)의 역할 구분
- 이벤트 루프와 태스크 큐 / 마이크로태스크 큐
- 콜백 함수와 Promise의 구조적 차이
- 클로저와 메모리 유지 원리
- Map / Set, WeakMap / WeakSet의 메모리 관점 활용

---

## 학습 전의 나

- 비동기 문제를 “실행 순서가 꼬였다”라고만 인식했다
- Promise는 콜백을 편하게 쓰기 위한 문법이라고 생각했다
- JS가 모든 비동기 작업을 직접 처리한다고 막연히 생각했다
- 클로저는 개념은 알지만 메모리와 연결해서 생각하지 않았다

---

## 가장 크게 바뀐 인식

비동기는 “순서의 문제”가 아니라  
**실행 주체와 책임이 분리된 구조의 문제**라는 점을 이해하게 됐다.

- JS는 콜 스택 실행만 담당한다
- 비동기 작업은 브라우저(Web API)가 처리한다
- 이벤트 루프는 실행 타이밍을 조정하는 역할을 한다

이 구조를 알고 나니,  
그동안 겪었던 비동기 버그들이 감이 아니라 **설명 가능한 문제**가 되었다.

> **비동기를 다룬다는 것은,  
> 실행 순서를 외우는 것이 아니라 구조를 이해하는 일이었다.**

---

## 이해가 어려웠던 지점

- 마이크로태스크 큐가 태스크 큐보다 우선되는 이유
- 클로저로 인해 변수가 유지되는 정확한 조건
- WeakMap / WeakSet이 언제 메모리에서 해제되는지

이 부분들은 한 번에 이해되지 않았고,  
md 파일로 정리하면서 여러 번 다시 생각하게 되었다.

---

## 실무에 바로 적용할 수 있는 기준

- 비동기 로직을 설계할 때 실행 순서를 가정하지 않는다
- Promise 체인은 “결과”가 아니라 “상태 변화”로 이해한다
- 클로저를 사용할 때 참조가 끊기는 시점을 의식한다
- Map과 WeakMap을 사용할 때 데이터의 소유권과 생명주기를 먼저 고민한다

---

## 이번 주의 아쉬운 점

- 이해에 집중하느라 코드 실험을 충분히 하지 못했다
- 일부 개념은 말로 설명하면 아직 막히는 부분이 있다

다음 주에는 간단한 예제라도 직접 실행해 보면서  
설명을 더 단단하게 만들고 싶다.

---

## 다음 주 계획

- 비동기 흐름을 코드 예제로 다시 확인하기
- 제너레이터와 비동기 추상화 학습
- 상태 관리로 넘어가기 전에 “상태”의 정의부터 정리하기

---

## 한 줄 회고

> 비동기는 복잡한 게 아니라,  
> 내가 구조를 모르고 순서만 외우려 했던 문제였다.
