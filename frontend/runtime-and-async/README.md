# Runtime and Async

## 핵심 질문
자바스크립트는 단일 스레드인데, 어떻게 비동기 처리가 가능한가?

이 질문에 답하지 못한 채  
비동기 코드를 감각적으로만 다루고 있다는 느낌이 들었다.

---

## 왜 이 주제를 공부했는가

비동기 코드에서 발생하는 문제를  
“실행 순서가 꼬였다”, “타이밍 문제인 것 같다”처럼  
정확한 근거 없이 감으로 해결하고 있다는 느낌이 들었다.

특히 다음과 같은 상황에서 명확한 설명을 하지 못했다.

- 왜 `setTimeout`보다 `Promise.then`이 먼저 실행되는가
- 비동기 작업은 자바스크립트가 직접 처리하는가
- 함수 실행이 끝났는데 변수는 왜 메모리에 남아 있는가

이 폴더는  
**비동기 동작을 ‘결과’가 아니라 ‘실행 구조’로 이해하기 위해** 정리한 기록이다.

---

## 이 폴더에서 다루는 주제

이 디렉토리에서는 자바스크립트 실행 환경과 비동기 처리 흐름을  
다음과 같은 관점에서 정리한다.

- 자바스크립트 런타임의 구성 요소
- JS 엔진과 브라우저(Web API)의 역할 분리
- 이벤트 루프와 큐의 동작 방식
- 콜백과 Promise의 구조적 차이
- 클로저와 메모리 유지 원리
- 컬렉션(Map / Set)과 메모리 관리 전략

---

## 정리 기준

각 파일은 “개념 설명”보다 아래 질문에 답하는 것을 목표로 한다.

- 왜 이런 동작이 발생하는가?
- 내가 이전에 오해했던 지점은 무엇이었는가?
- 이 구조를 이해하면 어떤 판단이 가능해지는가?

정리는 다음 흐름을 따른다.

> **개념 → 헷갈렸던 지점 → 구조적 이해 → 실무 판단 기준**

---

## 학습 후 달라진 점

이 주제를 학습하며 다음과 같은 변화가 있었다.

- 비동기 버그를 실행 순서가 아닌 **구조 관점**에서 분석하게 됨
- Promise와 async/await을 “편의 문법”이 아니라 **비동기 상태 모델**로 인식
- 클로저를 사용할 때 메모리 수명과 참조 관계를 의식하게 됨
- Map / WeakMap 사용 시,  
  단순한 자료구조가 아니라 **데이터의 소유권과 생명주기**를 먼저 고민하게 됨

---

## 파일 구성 안내
> 각 문서는 독립적으로 읽을 수 있으며,  
> 관심 있는 주제부터 선택해 읽어도 무방하다.

- [`runtime-model.md`](./runtime-model.md)  
  자바스크립트 런타임의 구성과 실행 주체 정리

- [`event-loop.md`](./event-loop.md)  
  이벤트 루프, 태스크 큐, 마이크로태스크 큐 흐름 정리

- [`web-api.md`](./web-api.md)  
  비동기 작업을 처리하는 브라우저 영역(Web API)의 역할

- [`callback-vs-promise.md`](./callback-vs-promise.md)  
  콜백과 Promise의 구조적 차이와 등장 배경

- [`closure-and-memory.md`](./closure-and-memory.md)  
  클로저와 메모리 유지, 참조 관계에 대한 정리

- [`map-and-set.md`](./map-and-set.md)  
  Map / Set의 사용 의도와 컬렉션 설계 관점

- [`weakmap-and-weakset.md`](./weakmap-and-weakset.md)  
  약한 참조와 가비지 컬렉션 관점에서의 활용

---

## 이후 확장 방향

이 폴더의 내용은 이후 다음 주제로 자연스럽게 확장될 수 있다.

- 고급 비동기 추상화 (`async-abstraction`)
- 상태 관리에서의 비동기 흐름
- 성능 최적화와 이벤트 루프의 관계

이 README는 완성본이 아니라,  
**학습이 진행되며 계속 수정·보완되는 기준 문서**로 유지한다.
